---
title: "002-Population_genetics"
author: "Rebecca Cheek"
date: "12/12/2020"
output: html_document
---


```{r message=FALSE, warning=FALSE, include=FALSE}
##############
### Libraries 
##############
library(tidyverse)
library(ade4)
library(LEA)
library(adegenet)
library(spdep)
library(hierfstat)
library(PopGenReport)
library(ggthemes)
library(mmod)
library(spdep)
library(MASS)
library("poppr")
library("pegas")
library("ape")
library(geodist)
library(vcfR)
library(vegan)
library(hierfstat)
library(lme4)
library(gdata)
library(ggthemes)
library(psych)
library(maptools)
library(rgdal)
library(gridExtra)
library(RColorBrewer)
library(strataG)

set.seed(666)

```

We have individuals from 8 lakes, including the original source population in Clear Water Minnesota and the original CO introduced population. 

No individuals failed our missingness threshold of 60%
Carter = 20
Clear_Water = 23
Dillon = 20
Grand = 20
Gross = 29
Jefferson = 20
Lower_Twin = 16
Ruedi = 20

Lower thresholds quickly reduced the number of individuals we were able to retain, so we opted to maximize the number of individuals and SNPs we retained given the limited structure seen in the STACKs tests. 


First, check to see how much missing data is in the non-imputed missing data and see if it differs from each population as this could skew population structure analyses. We will also re-run our PCA with a more stringent filter regime to see how this affects our results. If the results differ, then that could indicate that our results are biased by missing data. 

```{r}

#read in and convert genomic data using the .raw Plink file thats been imputed and includes all the SNPs 

gen <- read.PLINK("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/mysis_clean.raw", parallel = F)

dim(gen)
# 168 36882 = 6196176

gen <-as.matrix(gen)

mode(gen) <- "numeric"

sum(is.na(gen)) #2294578 missing so 37% total 

#convert to a data frame
gen.imp <- as.data.frame(gen)

#convert the rownames to collumn
gen.imp$individual_id <- rownames(gen.imp)


#Read in the environmental data
env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env.csv")


gen.imp <- left_join(gen.imp, env[,c(1,5)], by="individual_id")


#count the number of NA's for each lake to make sure the missing data isn't all restricted to one Lake
#this takes a long time to run
 gen.imp  %>% 
   group_by(Lake_name) %>% 
   summarise_all(~sum(is.na(.))) %>% 
   transmute(Lake_name, sumNA = rowSums(.[-1]))


# Lake_name      sumNA/total number sites
# Carter          	268986/6196176	=	0.04341161
# Clear_Water      	309822/6196176	=	0.05000213
# Dillon	          282586/6196176	= 0.04560652
# Grand           	253726/6196176	= 0.0409488
# Gross	            417796/6196176	= 0.06742804
# Jefferson       	279200/6196176	= 0.04506005
# Lower_Twin	      215352/6196176	= 0.03475563
# Ruedi	            267110/6196176  = 0.04310885
 
 missing_indiv <- gen.imp  %>% 
   group_by(individual_id) %>% 
   summarise_all(~sum(is.na(.))) %>% 
   transmute(individual_id, sumNA = rowSums(.[-1]))
 
  missing_indiv$total <-6196176
 
missing_indiv<- transform(missing_indiv, missing= sumNA / total)


```

We can first run SNMF from the R package LEA to determine our most likely value of K and create and then use lfmm to impute the missing values in the dataset that we can use for additional analyses that require complete dataframes. The structure like plots will  helps us determine if individuals from different lakes can be distinguished from each other, or if it would be more accurate to consider them all one population since they share such a recent genetic lineage. 
		Because we have 8 lakes and one lake with potential genetic differentiation (giant vs. regular morphs in Gross), we will test k values from 1:9 with 10 replicate runs. 

```{r echo=FALSE, message=FALSE, warning=FALSE}


#############################
# SNMF analysis in R using LEA & LFMM
##########################

#determine the most likely value of K (clusters). Choosing the number of clusters is based on the cross-entropy criterion. This criterion
# is also used by the program snmf. The cross-entropy criterion is based on the prediction of a fraction of masked genotypes (matrix completion), and on the cross-validation approach. Smaller values of the cross-entropy criterion usually mean better
# runs. We perform runs for 9 values of K, and choose the value of K for which the cross-entropy
# curve exhibits a plateau or exhibits a clear minimum value. 

mysis_geno <- vcf2geno(input.file = "C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/mysis_clean_imputed.vcf")


mysis_k  <- snmf(mysis_geno, K = 1:9, ploidy = 2, rep=10, entropy = T, alpha = 100, project= "new")

# plot cross-entroypy criterion for each K
K <-summary(mysis_k)$crossEntropy %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("temp") %>%
  mutate(K = as.numeric(str_extract(temp, "(\\d)+"))) %>%
  dplyr::select(-temp)

# choose K for which the function plateaus or increases sharply
kplot <-ggplot(K, aes(x = K, y = mean)) +
  geom_line(color = "black", size = 0.25 ) +
  geom_segment(aes(x = K, y = min, xend = K, yend = max)) +
  geom_point(shape = 21, size = 4, color = "black", fill = "darkorange") +
  scale_x_continuous(breaks = seq(0, 10, by = 1)) +
  labs(x = "number of ancestral populations", y = "cross-entropy criterion") +
  theme_few()

kplot

#Import the environmental data with the locality information, but filter out the individuals that were removed during filtering  

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env_final.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clearwater", "Lower_Twin"="Lower Twin")) 
 


#looks like k=1 is the most likely number of clusters with the imputed data since cross entropy increases with more clusters but K=2 also looks like it has 
#fairly minimal entropy. 
# identify best run for chosen K value
run <- which.min(cross.entropy(mysis_k, K = 2))

# extract q.matrix. The qmatrix object contains the matrix of ancestry coefficients
#for each individual for K clusters

q.matrix <- Q(mysis_k, K = 2, run = run) %>% 
  as.data.frame() 

mysis.q.matrix <- cbind(env, q.matrix) %>% 
  arrange(desc(Easting)) %>% 
  gather(cluster, value, V1:V2, factor_key=TRUE) %>% 
  group_by(individual_id)


mysis.q.matrix <- mysis.q.matrix  %>% 
   mutate(Lake_name = recode_factor(Lake_name,"Clearwater"= "Clearwater", "Lower_Twin"="Lower Twin")) 
  
#order by the lakes in the correct order
Lake <- as.data.frame(c("Carter", "Clearwater", "Dillon","Grand", "Gross", "Jefferson", "Lower Twin", "Ruedi"))
names(Lake)[1] <- "Lake_name"

mysis.q.matrix <- left_join(Lake,mysis.q.matrix, by="Lake_name") 


mysis.q.matrix$individual_id <- reorder(as_factor(mysis.q.matrix$individual_id), as_factor(mysis.q.matrix$Lake_name))


#Lets visualise the results with a barplot
snmf.bar <- ggplot(mysis.q.matrix,aes(fill=cluster, y=value, x=individual_id))+
  geom_bar( stat="identity",  width=.75 ) +
    scale_fill_manual(values=c("royalblue","wheat"))+
  labs(x = "", y = "Ancestry")+
  theme_few()+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.position = "none",
              axis.ticks.x = element_blank())
  

snmf.bar

```
We can see that K=1 is the number of ancestral populations most supported my minimum cross entropy criterion. Which makes complete sense given the seeding of shrimp from the same source population (s). However, looking at K=2 which had a fairly low cross entropy we see there a lot of mixing with perhaps some separation of Gross Lake individuals. We can analyze this sepperation of Gross Lake individuals in further analyses.  


To get a sense of the neutral population structure, we will use the liberal "neutral" dataset that has the 7 puntative adaptive loci flagged by PCAdapt, and the 199 filtered out. So 16,943 imputed SNPs for neutral genetic structure using PCA and DAPC. 

First, lets read in the data and convert them into the relevant formats for some of the analyses to start...

```{r}

# Load Data

#read in filtered data as a genind object & convert to different formats 

mysisvcfr <- read.vcfR("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.vcf")

mysis_genind <-vcfR2genind(mysisvcfr)

#read in raw plink files and convert to genlight and matrix
mysisgen <- read.PLINK("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/mysis_clean_imputed.raw", map.file ="C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/mysis_clean.map",x= "genlight", n.cores=NULL, parallel = F)

gen <- read.PLINK("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/mysis_clean_imputed.raw", parallel = F)

gen <- as.matrix(gen)

#make sure there are no NAs
sum(is.na(gen)) 


genfile <- as.matrix(gen[,-1], row.names = FALSE, col.names=FALSE)


#convert to matrix 
genfile <- as.matrix(mysisgen [,-1], row.names = FALSE, col.names=FALSE)


genfile <- as.matrix(mysisgen, row.names = FALSE, col.names=FALSE)

mode(genfile) <- 'numeric'  #needs to be numeric for some reason and matrix was character


#Import the environmental data with the locality information, but filter out the individuals that were removed during filtering  

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env_final.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clearwater", "Lower_Twin"="Lower Twin")) 
 

# #If I wanted to filter individuals use anti_join
# mysis_filtered <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - mysis/data/filtered_data/filtered_individuals.csv") %>% 
#   dplyr::rename("individual_id"="INDIVIDUALS")
# 
# 
# pred <- anti_join(env, mysis_filtered,  by="individual_id")


#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile
indiv_id <- rownames(genfile)

env <- env[order(match(env[,1], rownames(genfile))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(genfile))


#Need to first assign all individuals to the correct population

mysis_genind@pop <- as.factor(env$Lake_name) 


#convert to genlight
mysis_genlight <-vcfR2genlight(mysisvcfr)

#convert to genepop
mysis.pop<- adegenet::genind2genpop(mysis_genind)


```


Calculate pairwise Fst using the whitelist of putative SNPs flagged in the RDA within popualtions, and convert vcf to genepop


```{r}

#get the col pos and snp id from the filtered vcf 

pos_snp <- read.table("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.txt")

colnames(pos_snp) <- c("chrom","pos","snp_id")

 #separate the SNP ID which includes the locus and col
pos_snp <- separate(pos_snp, snp_id ,          
                     c("locus", "col"))


#Select just the locus and col information to make a whitelist for Stacks

whitelist <- pos_snp %>% 
  dplyr::select(c("locus", "col"))

dim(distinct(whitelist)) #18242 


#make a whitelist for the RDA SNPS
# pgirmess::write.delim(whitelist, file = "C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_whitelist_for_fst.txt", quote = FALSE, row.names = FALSE, sep = "\t",col.names = FALSE )

```

#run from the neutral snps directiory
```{sh}
#!/bin/bash

#SBATCH --job-name=populations
#SBATCH --output=./fst_stats/populations.out
#SBATCH --error=./fst_stats/populations.err
#SBATCH --mail-user=Rebecca.G.Cheek@gmail.com
#SBATCH --mail-type=END

source ~/.bashrc

###activate conda environment
module purge

module load slurm/alpine

conda activate stacks

populations -P ~/mysis -O /home/rgcheek/mysis/pre_filter/filtered_data/imputed_data/neutral_snps/fst_stats -W ./mysis_neutral_whitelist_for_fst -M ../../../../mysis_popmap_final

```



01- PCA
  Principal Components Analysis is a multivarate analysis that allows you to determine if population structure (genetic differentiation) is evident, and how much of the genetic variance may be explained by our first two components.
  We will do a "final" PCA using LEA. But will validate our result here. 

  
```{r}  
library(factoextra)
library(magrittr)



mysisvcfr <- read.vcfR("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/mysis_clean_imputed.vcf")

mysis_genind <-vcfR2genind(mysisvcfr)

#### Testing
#As recommended by T. Jombart, with the function find.clusters() we used the maximum possible number of PCA axis which is 18 here (2* number of clusters). 

grp <- find.clusters(mysis_genind, max.n.clust = 9, n.pca = 18, choose.n.clust = FALSE) 

#The K means procedure detected 3 groups. We will use this number of group in the discriminant analysis (function dapc()). 
grp$grp

mysis_pca<-dudi.pca(genfile, scannf = FALSE, nf = 2)

dapc1 <- dapc(mysis_genind, grp$grp, n.pca = 18, n.da = 9) 
scatter(dapc1) # plot of the groups

#looks like there could be 3 groups

factoextra::fviz_eig(mysis_pca) #looks like the first PCA axis explains most of the variance

groups <- as.factor(env$Lake_name)

s.class(mysis_pca$li,
             fac= groups, # color by groups
            col = rainbow(9),
        cellipse = 0)

#Looks like individuals mostly cluster on top of each other apart from Gross

```

We used RDA and PCADAPT to filter out strong putative candiate snps under selection from the dataset that could be biasing our neutral population genetic inference. Can do a PCA with just the RDA function from vegan and no predictors to do a PCA. 


```{r}
#plot out the imputed snps following filtering and imputation

mysis_gen <- read.PLINK("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.raw", parallel = F)

dim(mysis_gen)

#should be 18,220 snps following preliminary filters and removal of the 7 outliers from PCAdapt and 215 outliers from RDA, one of which was shared by both tests. 

#read plink reads it in as a genlight but scripts wants a genind so convert to a dataframe and then genind 

gen <-as.matrix(mysis_gen)


mode(gen) <- "numeric"

sum(is.na(gen)) 


#now we can use the rda function from the vegan package which is the same thing as a pca

mysis.pca1 <- rda(gen) #PCA using rda function 


summary(mysis.pca1)$cont 

screeplot(mysis.pca1, main = "Screeplot: Eigenvalues of Predictor Variables")


#We'll store our synthetic PC axis predictor as pred.PC1 for use in mapping.

pred.PC1 <- scores(mysis.pca1, choices=1, display="sites", scaling=0)


#quick and dirty plot
plot(pred.PC1)

#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile
indiv_id <- rownames(gen)

env <- env[order(match(env[,1], rownames(gen))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(gen))



##plot PCA in ordination space
###### To highlight individuals by library 
#custom color pallet
myCol2 <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c", "#C273F9", "#F973CA", "#17A589") # 8 colors for our Lakes 


#Import the environmental data with the locality information, but filter out the individuals that were removed during filtering  

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env_final.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clear Water", "Lower_Twin"="Lower Twin")) 
 


#Extract the scores from the pca
#Be sure to scale everything symmetrically by using the scaling=3 argument which will scale based on the square root of the eigenvalues
mysis_sam_sco <- scores(mysis.pca1, choices = 1:3, display = "sites", scaling=3)
mysis_sam_tbl <- as_tibble(mysis_sam_sco)
mysis_sam_tbl <- mutate(mysis_sam_tbl, individual_id=rownames(mysis_sam_sco),
                       ccatype = "sites")

mysis_sam_tbl <- left_join(env, mysis_sam_tbl, by="individual_id")


#extract the loading scores of the snps 

mysis_spp_sco <- scores(mysis.pca1, display = "species", scaling=3)
mysis_spp_tbl <- as_tibble(mysis_spp_sco)
mysis_spp_tbl <- mutate(mysis_spp_tbl, vgntxt=rownames(mysis_spp_sco),
                       ccatype = "species")

mysis_sam_tbl$Lake_name <- factor(mysis_sam_tbl$Lake_name, 
  levels=c("Carter", "Clear Water", "Dillon","Grand","Gross", "Jefferson", "Lower Twin", "Ruedi"))

#with ggplot
pc_plot_12 <- ggplot(data=mysis_sam_tbl,aes(x=PC1, y=PC2, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 1 (1.23%)") + ylab("PC Axis 2 (0.99%)") +
   theme(
  #legend.position =c(.18,.28),
   #      legend.justification = c("right", "top"),
   #      legend.title = element_text(size=12, face="bold"),
   #      legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_12

pc_plot_13 <- ggplot(data=mysis_sam_tbl,aes(x=PC1, y=PC3, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 1 (1.23%)") + ylab("PC Axis 3 (0.80%)") +
   theme(
     # legend.position =c(.18,.28),
     #    legend.justification = c("right", "top"),
     #    legend.title = element_text(size=12, face="bold"),
     #    legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_13

pc_plot_23 <- ggplot(data=mysis_sam_tbl,aes(x=PC2, y=PC3, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 2 (0.99%)") + ylab("PC Axis 3 (0.80%)") +
   theme(
     # legend.position =c(.18,.28),
     #    legend.justification = c("right", "top"),
     #    legend.title = element_text(size=12, face="bold"),
     #    legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_23



```

It's hard to discern how many clusters there could be. So we can use DAPC to try and pick out genetic clusters.

DAPC transforms your data to maximize the differences among the assigned groups. Basically, PCA is used to create related groups (PCs). The number of PCs retained greatly influences the end results, so cross-validation is required to identify how many PCs to retain in the final analysis. Discriminant analysis (DA) is then applied to maximize the difference between assigned genetic clusters. As opposed to Bayesian approaches, which use a priori groups, this multivariate method does not make assumptions about panmixia or other groupings. 

```{r}

mysisvcfr <- read.vcfR("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.vcf")

mysis_genind <-vcfR2genind(mysisvcfr)

#Import the environmental data with the locality information, but filter out the individuals that were removed during filtering  

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env_final.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clearwater", "Lower_Twin"="Lower Twin")) 
 

# #If I wanted to filter individuals use anti_join
# mysis_filtered <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - mysis/data/filtered_data/filtered_individuals.csv") %>% 
#   dplyr::rename("individual_id"="INDIVIDUALS")
# 
# 
# pred <- anti_join(env, mysis_filtered,  by="individual_id")


#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile

env <- env[order(match(env[,1], rownames(genfile))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(genfile))


#Need to first assign all individuals to the correct population

mysis_genind@pop <- as.factor(env$Lake_name) 


## population values read in correctly?
summary(mysis_genind@pop)

####### A. Use cross-validation to determine how many PCs to retain ####### 
# This checks how many PCs should be retained as the number of PCs directly impacts the DAPC results
par(mar=c(1,1,1,1)) #set margins 


xval <- xvalDapc(tab(mysis_genind, NA.method="mean"), pop(mysis_genind), parallel = "multicore", ncpus = 4)

####### B. Use the results from Part A to focus in on how many PCs to retain. Analyze the PCs surrounding the peak in proportion of successful outcome prediction from DAPC cross-validation plot. ####### 
# It looks like the values reach a peak around axis 100. So, we re-run xvalDAPC with more repetitions around these PC values 
# This will take a long time to run (about 1 hour)

system.time(xval<-xvalDapc(tab(mysis_genind, NA.method="mean"), pop(mysis_genind), n.pca=60:100, n.rep=100, parallel="multicore", ncpus=4))

####### C. Review the results ####### 
xval[-1] ## retained 73 PCs & 7 discriminant functions saved

# $n.pca: 73 first PCs of PCA used
# $n.da: 7 discriminant functions saved
# $var (proportion of conserved variance): 0.514

#### D. Plot results 

#first read the dapc results as a new data frame

dapc_results <- xval


#custom color pallet
myCol3 <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c", "#C273F9", "#F973CA", "#17A589" ) # 8 colors for our Lakes 

## With labels to identify clusters by region
scatter(dapc_results$DAPC,posi.da="bottomright", bg="white",cstar=0, col=myCol3, scree.pca=FALSE)


#extract the values from the DAPc model

myssi_dapc <- dapc_results$DAPC

#make sure hte factor level of the lakes in the DAPC results match the labels

dapc_results$DAPC$grp <- factor(dapc_results$DAPC$grp , levels=c("Carter", "Clearwater", "Dillon","Grand", "Gross", "Jefferson", "Lower Twin", "Ruedi"))


lakes<-c(c("Carter", "Clearwater", "Dillon","Grand", "Gross", "Jefferson", "Lower Twin", "Ruedi"))

## With labels for better figure
scatter(dapc_results$DAPC, cex=1.5, legend=T, txt.leg=lakes, clabel=FALSE, posi.leg="topright", posi.da="bottomright", bg="white",cstar=0, col=myCol3, scree.pca=FALSE, cleg = 0.75, xax = 1, yax = 2, inset.solid = 1)


scatter(dapc_results$DAPC, cex=2.5, legend=FALSE, txt.leg=lakes, clabel=FALSE, posi.leg=NA, posi.da="bottomright", bg="white",cstar=0, col=myCol3, scree.pca=FALSE, cleg = 0.75, xax = 1, yax = 2, inset.solid = 1)

## results suggest Gross morphs are grouped together, Clearwater is separate from other lakes on DA2


```


Admixture algorithm uses cross-validation to estimate the number of principal components used in models to estimate the optimal number of genetic clusters (K). 
ANALYSES: To run Admixture, be aware of the path to all relevant files. Here, we worked in an Admixture folder that included the executable and the .bed, .bim, and .fam files with the prefix: mysis_clean_imputed_neutral. 
Downloaded the admixture conda package and will just run in the shell 

```{bash}
#admixture need integers for the chromosome names so use the rename_vcf_scaffolds_for_plink.py script to assign numeric chromosomes. Since there is only un it will be 1001

## First, we need to identify the optimal number of K-means clusters by running the algorithm across different K values and identifying the K with the lowest cross-validation errors. 

cat admixture_k_opt.sh

#!/bin/bash

### Test to see how many clusters are optimal
# run the CV
for K in 1 2 3 4 5 6 7 8 9; \
do admixture --cv  mysis_neutral_snps_non_imputed.bed $K | tee log_fin${K}.out; done

```

Now look at the CV results for each of the runs. 

```{bash}
# extract CV scores from each run
grep -h CV log*.out > cv_opt_output.txt

# review the output
cat cv_opt_output.txt

# results below
CV error (K=1): 0.31976
CV error (K=2): 0.33544
CV error (K=3): 0.35894
CV error (K=4): 0.38093
CV error (K=5): 0.40818
CV error (K=6): 0.43413
CV error (K=7): 0.45999
CV error (K=8): 0.48423
CV error (K=9): 0.50919


```

Based on the CV errors stored in cv_opt_output.txt, we see that K=1 has the lowest score. Using K = 1 & 2, re-run Admixture. 

```{bash}
conda activate base

cat admixture_k_final.sh

#note that admixture doesn't like non-human chromosomes so covert to integers 
awk '{$1="0";print $0}' $FILE.bim > $FILE.bim.tmp
mv $FILE.bim.tmp $FILE.bim

#can now run admixture
### Run for optimal K
for K in 1 2; \
do admixture mysis_clean_imputed_neutral.bed $K; done
# this will output plink.$K.Q files to use for plotting
```
We can see that K=1 is the number of ancestral populations most supported my minimum cross entropy criterion. Which makes complete sense given the seeding of shrimp from the same source population (s). However, looking at K=2 which had a fairly low cross entropy we see there a lot of mixing with perhaps some separation of Gross Lake individuals. 

PLOT RESULTS: We will read in the .Q files to create the admixture plots as barplots. We will use the .fam for groupings in the plot.

```{r}

### Read in data

tbl2=read.table("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps_non_imputed.2.Q")

tbl2$individual_id <- rownames(gen)

#get the lake names 

tbl2 <- left_join(tbl2, env, by="individual_id")


### 2. Set colors for different number of clusters
myCol2 <-c("royalblue", "wheat")


mysis.admixture <- tbl2 %>% 
  gather(cluster, value, V1:V2, factor_key=TRUE) %>% 
  group_by(individual_id)

#change the factor levels so it matches with the timeline of source
mysis.admixture <- mysis.admixture %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clearwater"= "Clear Water", "Lower_Twin"="Lower Twin",)) 

#make a dummy variable to force the rows to be in the correct order
Lake <- as.data.frame(c( "Clear Water", "Lower Twin","Grand", "Carter","Dillon","Ruedi","Gross", "Jefferson"))

names(Lake)[1] <- "Lake_name"

mysis.admixture <- left_join(Lake,mysis.admixture, by="Lake_name") 


#create a dummy variable so that the individuals plot in the correct order

### 3. Plot the different admixture results
# For adding x-axis with population labels
# Each row is an individual, column 1 = population, col 2 = individual ID

## K = 2 populations

#Lets visualize the results with a barplot
snmf.bar <- ggplot(mysis.admixture,aes(fill=cluster, y=value, x=individual_id))+
  geom_bar( stat="identity",  width=.75 ) +
    scale_fill_manual(values=c("royalblue","wheat"))+
  labs(x = "", y = "Ancestry")+
  theme_few()+ 
  facet_grid(~fct_inorder(Lake_name), switch = "x", scales = "free", space = "free") +
  theme(legend.position = "none",
              axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
     axis.line.x.bottom = element_blank(),
      axis.line.y.left = element_blank())
  

snmf.bar

```


#calculate effective popualtion size with strataG. 

```{r message=FALSE, warning=FALSE}

#Effective population size using StrataG

mysisvcfr <- read.vcfR("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.vcf")

mysis_genind <-vcfR2genind(mysisvcfr)

mysis_gen <- as.matrix(mysis_genind)


#Import the environmental data with the locality information

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clearwater", "Lower_Twin"="Lower Twin")) 

#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile

env <- env[order(match(env$individual_id, rownames(mysis_gen))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(mysis_gen))

#Need to first assign all individuals to the correct population

mysis_genind@pop <- as.factor(env$Lake_name) 

## population values read in correctly?
summary(mysis_genind@pop)
#create gtypes object 

mysis_gtypes <- strataG::genind2gtypes(mysis_genind)

#estimate effective population size of the different lakes using ld method Estimate Ne from linkage disequilibrium based on Pearson correlation approximation following Waples et al 2016. 

mysis.Ne <- strataG::ldNe(mysis_gtypes, by.strata =T, ci = 0.95)

mysis.Ne


```
We see higher Ne in the MI source population. This fists with what we know about the system since all populations have been sources from the same lake in MI and then CO, so there is evidence of a genetic bottleneck from MI. 


This lack of variation is actually a good thing. Because there is no significant hierarchical population structure, we can run analyses of selection using GEA analyses without worrying about spurious associations due to population genetic structure. 



#How does removing Gross affect results?


```{r}

#Quick tests to see if Gross Lake individuals skew the PCA, DAPC, and Structure analysis 

#filter out Gross Lake individuals using vcftools 

# vcftools --vcf mysis_clean_imputed_neutral_names_fix.vcf --keep mysis_sans_Gross --recode --out mysis_sans_gross_neutral_SNPs
 
#make a raw file
#plink --vcf mysis_sans_gross_neutral_SNPs.vcf --recode AD --out mysis_sans_gross_neutral_SNPs --allow-extra-chr

#Read in neutral data sans Gross Lake individuals for DAPC

mysisvcfr <- read.vcfR("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/filtered_data/imputed_data/neutral_snps/mysis_sans_gross_neutral_SNPs.vcf")

# 16943 SNPs and 139 individuals

mysis_genind <-vcfR2genind(mysisvcfr)

#the individual_ids have the population data too, so need to pull jsut the individual ID so I can merge the population data into the genind correctly 

genfile <- as.data.frame(mysis_genind)

#Import the environmental data with the locality information

env <- read.csv("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/mysis_env_final.csv")

env$Lake_name <- as.factor(env$Lake_name) 

#make sure the factor levels are correct
env <- env %>% 
  mutate(Lake_name = recode_factor(Lake_name,"Clear_Water"= "Clearwater", "Lower_Twin"="Lower Twin")) 

#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile

env <- env[order(match(env[,1], rownames(genfile))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(genfile))

#Need to first assign all individuals to the correct population

mysis_genind@pop <- as.factor(env$Lake_name) 

## population values read in correctly?
summary(mysis_genind@pop)

####### A. Use cross-validation to determine how many PCs to retain ####### 
# This checks how many PCs should be retained as the number of PCs directly impacts the DAPC results


xval <- xvalDapc(tab(mysis_genind, NA.method="mean"), pop(mysis_genind), parallel = "multicore", ncpus = 4)

####### B. Use the results from Part D to focus in on how many PCs to retain. Analyze the PCs surrounding the peak in proportion of successful outcome prediction from DAPC cross-validation plot. ####### 

# Here, we see the peak around 40-100. So, we re-run xval DAPC with more repetitions around these PC values 
# This will take a long time to run (about 1 hour)

system.time(xval<-xvalDapc(tab(mysis_genind, NA.method="mean"), pop(mysis_genind), n.pca=40:100, n.rep=100, parallel="multicore", ncpus=4))

####### C. Review the results ####### 
xval[-1] ## retained 50 PCs & 6 discriminant functions saved

# $n.pca: 50 first PCs of PCA used
# $n.da: 6 discriminant functions saved
# $var (proportion of conserved variance): 0.428

#### D. Plot results 

#first read the dapc results as a new data frame

dapc_results <- xval


#custom color pallet
myCol3 <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3", "#F973CA", "#17A589","#e31a1c" ) # 7 colors for our Lakes

## With labels to identify clusters by region
scatter(dapc_results$DAPC,posi.da="bottomright", bg="white",cstar=0, col=myCol3, scree.pca=FALSE)


#extract the values from the DAPc model

myssi_dapc <- dapc_results$DAPC

#make sure hte factor level of the lakes in the DAPC results match the labels

dapc_results$DAPC$grp <- factor(dapc_results$DAPC$grp , levels=c("Carter", "Clearwater", "Dillon","Grand", "Jefferson", "Lower Twin", "Ruedi"))


lakes<-c(c("Carter", "Clearwater", "Dillon","Grand", "Jefferson", "Lower Twin", "Ruedi"))

## With labels for better figure
scatter(dapc_results$DAPC, cex=1.5, legend=T, txt.leg=lakes, clabel=FALSE, posi.leg="topright", posi.da="bottomleft", bg="white",cstar=0, col=myCol3, scree.pca=FALSE, cleg = 0.75, xax = 1, yax = 2, inset.solid = 1)


scatter(dapc_results$DAPC, cex=2.5, legend=FALSE, txt.leg=lakes, clabel=FALSE, posi.leg=NA, posi.da="topright", bg="white",cstar=0, col=myCol3, scree.pca=FALSE, cleg = 0.75, xax = 1, yax = 2, inset.solid = 1)

## results suggest Clear Water is separate from other lakes with some separation from Grand 


```


Determine the most likely number of genetic clusters with snmf to see if removing Gross lake causes differences in how populations are structured

```{r echo=FALSE, message=FALSE, warning=FALSE}


#############################
# SNMF analysis in R using LEA
##########################

#determine the most likely value of K (clusters). Choosing the number of clusters is based on the cross-entropy criterion. This criterion
# is also used by the program snmf. The cross-entropy criterion is based on the prediction of a fraction of masked genotypes (matrix completion), and on the cross-validation approach. Smaller values of the cross-entropy criterion usually mean better
# runs. We perform runs for 9 values of K, and choose the value of K for which the cross-entropy
# curve exhibits a plateau or exhibits a clear minimum value. 

mysis_geno <- vcf2geno(input.file = "C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/redo_sans_jumbo/pre_filter/filtered_data/imputed_data/neutral_snps/mysis_neutral_snps.vcf")


mysis_k  <- snmf(mysis_geno, K = 1:9, ploidy = 2, rep=10, entropy = T, alpha = 100, project= "new")

# plot cross-entroypy criterion for each K
K <-summary(mysis_k)$crossEntropy %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("temp") %>%
  mutate(K = as.numeric(str_extract(temp, "(\\d)+"))) %>%
  dplyr::select(-temp)

# choose K for which the function plateaus or increases sharply
kplot <-ggplot(K, aes(x = K, y = mean)) +
  geom_line(color = "black", size = 0.25 ) +
  geom_segment(aes(x = K, y = min, xend = K, yend = max)) +
  geom_point(shape = 21, size = 4, color = "black", fill = "darkorange") +
  scale_x_continuous(breaks = seq(0, 10, by = 1)) +
  labs(x = "number of ancestral populations", y = "cross-entropy criterion") +
  theme_few()

kplot


#looks like k=1 is the most likely number of clusters with the imputed data since cross entropy increases with more clusters but K=2 also looks like it has 
#fairly minimal entropy. 
# identify best run for chosen K value
run <- which.min(cross.entropy(mysis_k, K = 2))

# extract q.matrix. The qmatrix object contains the matrix of ancestry coefficients
#for each individual for K clusters

q.matrix <- Q(mysis_k, K = 2, run = run) %>% 
  as.data.frame() 

mysis.q.matrix <- cbind(env, q.matrix) %>% 
  arrange(desc(Easting)) %>% 
  gather(cluster, value, V1:V2, factor_key=TRUE) %>% 
  group_by(individual_id)


mysis.q.matrix <- mysis.q.matrix  %>% 
   mutate(Lake_name = recode_factor(Lake_name,"Clearwater"= "Clear Water", "Lower_Twin"="Lower Twin")) 
  
#order by the lakes in the correct order
Lake <- as.data.frame(c("Carter", "Clear Water", "Dillon","Grand", "Jefferson", "Lower Twin", "Ruedi"))
names(Lake)[1] <- "Lake_name"

mysis.q.matrix <- left_join(Lake,mysis.q.matrix, by="Lake_name") 


mysis.q.matrix$individual_id <- reorder(as_factor(mysis.q.matrix$individual_id), as_factor(mysis.q.matrix$Lake_name))


#Lets visualise the results with a barplot
snmf.bar <- ggplot(mysis.q.matrix,aes(fill=cluster, y=value, x=individual_id))+
  geom_bar( stat="identity",  width=.75 ) +
    scale_fill_manual(values=c("royalblue","wheat"))+
  labs(x = "", y = "Ancestry")+
  theme_few()+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.position = "none",
              axis.ticks.x = element_blank())
  

snmf.bar

```


Finally, re-run PCA without Gross Lake individuals

```{r}
#plot out the imputed snps following filtering and imputation

mysis_gen <- read.PLINK("C:/Users/Rebecca/Colostate/GhalamborLab - Documents/Group Projects/mysis/data/filtered_data/imputed_data/neutral_snps/mysis_sans_gross_neutral_SNPs.raw", parallel = F)

dim(mysis_gen)

#should be 16,943 snps following preliminary filters and removal of the 69 outliers from PCAdapt

#read plink reads it in as a genlight but scripts wants a genind so convert to a dataframe and then genind 

gen <-as.matrix(mysis_gen)

mode(gen) <- "numeric"

sum(is.na(gen)) 

rownames(gen) <-rownames(genfile)

#now we can use the rda function from the vegan package which is the same thing as a pca

mysis.pca1 <- rda(gen) #PCA using rda function 


summary(mysis.pca1)$cont 

#screeplot(mysis.pca1, main = "Screeplot: Eigenvalues of Predictor Variables")


#We'll store our synthetic PC axis predictor as pred.PC1 for use in mapping.

pred.PC1 <- scores(mysis.pca1, choices=1, display="sites", scaling=0)


#quick and dirty plot
plot(pred.PC1)

#order the pred file so that it matches with the genetic data 
#first extract the rownames form the genfile
indiv_id <- rownames(gen)

env <- env[order(match(env[,1], rownames(gen))),]


#make sure the order of the phenotype and the genetic data are the same
identical(env$individual_id, rownames(gen))



##plot PCA in ordination space
###### To highlight individuals by library 
#custom color pallet
myCol2 <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3", "#F973CA", "#17A589","#e31a1c" ) # 9 colors for our Lakes plus 2 phenotypes



#Extract the scores from the pca
#Be sure to scale everything symmetrically by using the scaling=3 argument which will scale based on the square root of the eigenvalues
mysis_sam_sco <- scores(mysis.pca1, choices = 1:3, display = "sites", scaling=3)
mysis_sam_tbl <- as_tibble(mysis_sam_sco)
mysis_sam_tbl <- mutate(mysis_sam_tbl, individual_id=rownames(mysis_sam_sco),
                       ccatype = "sites")

mysis_sam_tbl <- left_join(env, mysis_sam_tbl, by="individual_id")


#extract the loading scores of the snps 

mysis_spp_sco <- scores(mysis.pca1, display = "species", scaling=3)
mysis_spp_tbl <- as_tibble(mysis_spp_sco)
mysis_spp_tbl <- mutate(mysis_spp_tbl, vgntxt=rownames(mysis_spp_sco),
                       ccatype = "species")

mysis_sam_tbl$Lake_name <- factor(mysis_sam_tbl$Lake_name, 
  levels=c("Carter", "Clearwater", "Dillon","Grand", "Jefferson", "Lower Twin", "Ruedi"))

#with ggplot
pc_plot_12 <- ggplot(data=mysis_sam_tbl,aes(x=PC1, y=PC2, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 1 (0.97%)") + ylab("PC Axis 2 (0.95%)") +
   theme(
  #legend.position =c(.18,.28),
   #      legend.justification = c("right", "top"),
   #      legend.title = element_text(size=12, face="bold"),
   #      legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_12

pc_plot_13 <- ggplot(data=mysis_sam_tbl,aes(x=PC1, y=PC3, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 1 (0.97%)") + ylab("PC Axis 3 (0.94%)") +
   theme(
     # legend.position =c(.18,.28),
     #    legend.justification = c("right", "top"),
     #    legend.title = element_text(size=12, face="bold"),
     #    legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_13

pc_plot_23 <- ggplot(data=mysis_sam_tbl,aes(x=PC2, y=PC3, fill=Lake_name)) +
    scale_fill_manual(values = myCol2)+
  #stat_ellipse(data=mysis_sam_tbl,aes(x=PC1, y=PC2, color=Lake_name),type = "norm") + #add ellipses
  geom_point(shape=21,  color="black", size=4) +# the shrimp
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
   theme_few()+
   labs(fill = "Lake Name")+ xlab("PC Axis 2 (0.95%)") + ylab("PC Axis 3 (0.94%)") +
   theme(
     # legend.position =c(.18,.28),
     #    legend.justification = c("right", "top"),
     #    legend.title = element_text(size=12, face="bold"),
     #    legend.text = element_text(size=12, face="bold"),
        axis.title=element_text(colour="black", size = 15,face="bold"),
        axis.text=element_text(colour="black", size = 13,face="bold"),
        plot.background = element_rect(fill = "transparent",colour = NA))

pc_plot_23



```
We can see that eliminating Gross Lake from the Neutral pop structure dosn't change the overall results. Perhaps some additional structure between Grand Lake and the other lakes and sepperation from Clearwater source, but nothing different with the structure analysis and PCA. 